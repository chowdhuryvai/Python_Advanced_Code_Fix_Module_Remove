import sys
import traceback
import ast
import re
import io
import contextlib
import keyword
import os
import datetime
import subprocess
from collections import defaultdict

class ChowdhuryVaiCodeFixer:
    def __init__(self):
        self.brand_name = "ChowdhuryVai"
        self.version = "v4.1"
        self.contact_info = {
            "Telegram": "https://t.me/darkvaiadmin",
            "Channel": "https://t.me/windowspremiumkey", 
            "Website": "https://crackyworld.com/"
        }
        self.removed_modules = []
        self.module_replacements = {}
        self.output_directory = "ChowdhuryVai_Fixed_Codes"
        
    def display_banner(self):
        banner = f"""
\033[1;92m
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║    ██████╗██╗  ██╗ ██████╗ ██╗    ██╗██╗   ██╗██████╗ ██╗   ██╗             ║
║   ██╔════╝██║  ██║██╔═══██╗██║    ██║██║   ██║██╔══██╗██║   ██║             ║
║   ██║     ███████║██║   ██║██║ █╗ ██║██║   ██║██████╔╝██║   ██║             ║
║   ██║     ██╔══██║██║   ██║██║███╗██║██║   ██║██╔══██╗██║   ██║             ║
║   ╚██████╗██║  ██║╚██████╔╝╚███╔███╔╝╚██████╔╝██║  ██║╚██████╔╝             ║
║    ╚═════╝╚═╝  ╚═╝ ╚═════╝  ╚══╝╚══╝  ╚═════╝ ╚═╝  ╚═╝ ╚═════╝              ║
║                                                                              ║
║          {self.brand_name} ADVANCED CODE FIXER, MODULE REMOVER & AUTO-SAVER {self.version} ║
║                               Professional Edition                           ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝
\033[0m
"""
        print(banner)
        
    def display_contact_info(self):
        print("\033[1;96m" + "═" * 70 + "\033[0m")
        print("\033[1;93mCONTACT INFORMATION:\033[0m")
        for platform, link in self.contact_info.items():
            print(f"\033[1;95m{platform:>12}: \033[1;97m{link}\033[0m")
        print("\033[1;96m" + "═" * 70 + "\033[0m")
        
    def create_output_directory(self):
        """Create output directory for saving fixed codes"""
        try:
            if not os.path.exists(self.output_directory):
                os.makedirs(self.output_directory)
                print(f"\033[1;92m✓ Created output directory: {self.output_directory}\033[0m")
            return True
        except Exception as e:
            print(f"\033[1;91m✗ Error creating directory: {e}\033[0m")
            return False
        
    def generate_filename(self, original_name="", prefix="fixed"):
        """Generate automatic filename with timestamp"""
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        
        if original_name and original_name != "manual_input.py":
            # Extract base name without path and extension
            base_name = os.path.splitext(os.path.basename(original_name))[0]
            # Remove invalid characters
            base_name = re.sub(r'[<>:"/\\|?*]', '_', base_name)
            filename = f"{prefix}_{base_name}_{timestamp}.py"
        else:
            filename = f"{prefix}_code_{timestamp}.py"
            
        return filename
        
    def save_code_automatically(self, code, original_filename="", custom_name=""):
        """Automatically save the fixed code to a .py file"""
        if not self.create_output_directory():
            return None
            
        output_dir = os.path.abspath(self.output_directory)
        
        if custom_name:
            filename = custom_name if custom_name.endswith('.py') else custom_name + '.py'
            # Clean filename
            filename = re.sub(r'[<>:"/\\|?*]', '_', filename)
        else:
            filename = self.generate_filename(original_filename)
        
        filepath = os.path.join(output_dir, filename)
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                # Add header comment
                header = f'''"""
Automatically Fixed Python Code
Generated by {self.brand_name} Code Fixer {self.version}
Timestamp: {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
Original file: {original_filename if original_filename else "Manual Input"}
Modules removed: {', '.join(self.removed_modules) if self.removed_modules else 'None'}
Contact: {self.contact_info['Telegram']}
Channel: {self.contact_info['Channel']}
Website: {self.contact_info['Website']}
"""

'''
                f.write(header + code)
            
            # Verify file was created
            if os.path.exists(filepath):
                file_size = os.path.getsize(filepath)
                print(f"\033[1;92m✓ Code successfully saved to: {filepath}\033[0m")
                print(f"\033[1;96m✓ File size: {file_size} bytes\033[0m")
                return filepath
            else:
                print("\033[1;91m✗ File was not created!\033[0m")
                return None
                
        except Exception as e:
            print(f"\033[1;91m✗ Error saving file: {e}\033[0m")
            return None
            
    def list_saved_files(self):
        """List all previously saved fixed files"""
        if not os.path.exists(self.output_directory):
            return []
        
        files = []
        try:
            for file in os.listdir(self.output_directory):
                if file.endswith('.py'):
                    filepath = os.path.join(self.output_directory, file)
                    create_time = os.path.getctime(filepath)
                    create_date = datetime.datetime.fromtimestamp(create_time).strftime("%Y-%m-%d %H:%M:%S")
                    file_size = os.path.getsize(filepath)
                    files.append((file, create_date, filepath, file_size))
        except Exception as e:
            print(f"\033[1;91mError reading directory: {e}\033[0m")
        
        return sorted(files, key=lambda x: x[1], reverse=True)
        
    def display_saved_files(self):
        """Display all saved files in a nice format"""
        files = self.list_saved_files()
        
        if not files:
            print("\033[1;97mNo saved files found in directory.\033[0m")
            print(f"\033[1;96mDirectory path: {os.path.abspath(self.output_directory)}\033[0m")
            return
        
        print("\n\033[1;94m" + "═" * 70 + "\033[0m")
        print("\033[1;93mPREVIOUSLY SAVED FILES:\033[0m")
        print("\033[1;94m" + "═" * 70 + "\033[0m")
        
        for i, (filename, create_date, filepath, file_size) in enumerate(files[:10], 1):
            print(f"\033[1;97m{i:2d}. {filename}\033[0m")
            print(f"    \033[1;96mCreated: {create_date} | Size: {file_size} bytes\033[0m")
            print(f"    \033[1;95mPath: {filepath}\033[0m")
            print()
            
    def analyze_syntax(self, code):
        """Analyze Python code for syntax errors"""
        try:
            ast.parse(code)
            return True, "Syntax is correct"
        except SyntaxError as e:
            return False, f"Syntax Error: {e.msg} at line {e.lineno}, column {e.offset}"
            
    def check_indentation(self, code):
        """Check for indentation issues"""
        lines = code.split('\n')
        issues = []
        indent_stack = [0]
        
        for i, line in enumerate(lines, 1):
            if line.strip() == '':
                continue
                
            current_indent = len(line) - len(line.lstrip())
            stripped_line = line.strip()
            
            # Check if line starts a block
            if stripped_line.endswith(':'):
                if current_indent != indent_stack[-1]:
                    issues.append(f"Line {i}: Incorrect indentation for block start")
                indent_stack.append(current_indent + 4)
            elif current_indent > indent_stack[-1]:
                issues.append(f"Line {i}: Unexpected indentation")
            elif current_indent < indent_stack[-1]:
                # Remove indentation levels from stack
                while indent_stack and current_indent < indent_stack[-1]:
                    indent_stack.pop()
                if current_indent != indent_stack[-1]:
                    issues.append(f"Line {i}: Inconsistent indentation")
                    
        return issues
        
    def detect_modules(self, code):
        """Detect all imported modules in the code"""
        modules = {
            'imports': [],
            'from_imports': [],
            'builtin_usage': defaultdict(list)
        }
        
        # Parse imports
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        modules['imports'].append(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        modules['from_imports'].append({
                            'module': node.module,
                            'imports': [alias.name for alias in node.names]
                        })
        except:
            # Fallback to regex if AST parsing fails
            import_pattern = r'^\s*import\s+([^\s,#]+)'
            from_pattern = r'^\s*from\s+([^\s,#]+)\s+import'
            
            for line in code.split('\n'):
                import_match = re.match(import_pattern, line)
                if import_match:
                    modules['imports'].append(import_match.group(1))
                
                from_match = re.match(from_pattern, line)
                if from_match:
                    modules['from_imports'].append({
                        'module': from_match.group(1),
                        'imports': []  # Simplified for regex
                    })
        
        return modules
        
    def remove_modules_and_fix(self, code):
        """Remove external modules and replace with built-in functionality"""
        self.removed_modules = []
        
        # Detect all modules
        modules = self.detect_modules(code)
        
        # Remove import statements
        lines = code.split('\n')
        cleaned_lines = []
        
        for line in lines:
            stripped_line = line.strip()
            
            # Skip import lines for external modules
            if (stripped_line.startswith('import ') or 
                stripped_line.startswith('from ')):
                
                # Keep only basic built-in modules
                keep_import = False
                builtin_modules = ['os', 'sys', 'math', 'time', 'datetime', 'json', 
                                 're', 'random', 'collections', 'itertools', 'functools']
                
                for builtin in builtin_modules:
                    if (f"import {builtin}" in stripped_line or 
                        f"from {builtin}" in stripped_line):
                        keep_import = True
                        break
                
                if not keep_import:
                    module_name = re.findall(r'^(?:import|from)\s+(\w+)', stripped_line)
                    if module_name and module_name[0] not in builtin_modules:
                        self.removed_modules.append(module_name[0])
                        continue
            
            cleaned_lines.append(line)
        
        code = '\n'.join(cleaned_lines)
        
        # Replace common module functions with built-ins
        replacements = {
            'numpy.array': 'list',
            'np.array': 'list',
            'pd.DataFrame': '{} # dict as simple dataframe',
            'requests.get': '# HTTP requests removed - use urllib instead',
            'plt.plot': '# plotting removed - no visualization',
            'soup.find': '# BeautifulSoup removed - use regex for simple parsing'
        }
        
        for old, new in replacements.items():
            code = code.replace(old, new)
            
        # Add helper functions for common operations
        helper_functions = '''
# Helper functions replacing external modules
def custom_mean(data):
    """Replace numpy.mean"""
    return sum(data) / len(data) if data else 0

def custom_max(data):
    """Replace numpy.max"""
    return max(data) if data else None

def simple_http_get(url):
    """Replace requests.get with urllib"""
    try:
        from urllib.request import urlopen
        response = urlopen(url)
        return response.read().decode('utf-8')
    except:
        return None

def parse_simple_html(html, pattern):
    """Replace BeautifulSoup with regex"""
    import re
    return re.findall(pattern, html)
'''
        
        # Add helpers if we removed relevant modules
        if any(module in ['numpy', 'pandas', 'requests', 'bs4'] for module in self.removed_modules):
            code = helper_functions + '\n' + code
            
        return code
        
    def fix_common_errors(self, code):
        """Fix common Python errors automatically"""
        fixes_applied = []
        
        # Fix print statements for Python 3
        if "print " in code and "print(" not in code:
            code = re.sub(r'print\s+(.+?)(?=\n|$)', r'print(\1)', code)
            fixes_applied.append("Converted Python 2 print statements to Python 3")
            
        # Fix common import issues
        if "import " in code and "from __future__ import print_function" not in code and "print " in code:
            code = "from __future__ import print_function\n" + code
            fixes_applied.append("Added print_function import for compatibility")
            
        # Fix common variable name issues
        lines = code.split('\n')
        for i, line in enumerate(lines):
            # Find variable assignments
            match = re.match(r'^(\s*)(\w+)\s*=\s*.+', line)
            if match:
                indent, var_name = match.groups()
                if keyword.iskeyword(var_name):
                    new_var = var_name + '_var'
                    code = code.replace(f' {var_name} =', f' {new_var} =')
                    code = code.replace(f' {var_name},', f' {new_var},')
                    code = code.replace(f'({var_name})', f'({new_var})')
                    fixes_applied.append(f"Changed keyword variable name '{var_name}' to '{new_var}'")
                    
        return code, fixes_applied
        
    def capture_output(self, code):
        """Execute code and capture output"""
        output_buffer = io.StringIO()
        error_buffer = io.StringIO()
        
        try:
            # Create a safe environment for execution
            safe_globals = {
                '__builtins__': __builtins__,
                'print': print,
                'len': len,
                'range': range,
                'list': list,
                'dict': dict,
                'str': str,
                'int': int,
                'float': float,
                'bool': bool,
                'sum': sum,
                'max': max,
                'min': min
            }
            
            with contextlib.redirect_stdout(output_buffer), contextlib.redirect_stderr(error_buffer):
                exec(code, safe_globals)
            return True, output_buffer.getvalue(), error_buffer.getvalue()
        except Exception as e:
            error_msg = f"{type(e).__name__}: {str(e)}"
            return False, "", error_msg
            
    def suggest_improvements(self, code):
        """Suggest code improvements"""
        suggestions = []
        
        # Check for long lines
        lines = code.split('\n')
        for i, line in enumerate(lines, 1):
            if len(line) > 79:
                suggestions.append(f"Line {i}: Consider breaking long line (>79 characters)")
                
        # Check for missing docstrings in functions
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef) and not ast.get_docstring(node):
                    suggestions.append(f"Function '{node.name}': Add a docstring")
        except:
            pass
            
        # Check for unused imports
        if "import" in code:
            suggestions.append("Review imports - remove unused ones for better performance")
            
        return suggestions
        
    def format_code(self, code):
        """Basic code formatting"""
        # Remove extra blank lines
        lines = code.split('\n')
        formatted_lines = []
        prev_blank = False
        
        for line in lines:
            if line.strip() == '':
                if not prev_blank:
                    formatted_lines.append('')
                    prev_blank = True
            else:
                formatted_lines.append(line.rstrip())
                prev_blank = False
                
        return '\n'.join(formatted_lines)
        
    def process_code(self, user_code, remove_modules=True, original_filename=""):
        """Main method to process and fix code"""
        print("\n\033[1;94m" + "═" * 70 + "\033[0m")
        print("\033[1;93mANALYZING YOUR CODE...\033[0m")
        print("\033[1;94m" + "═" * 70 + "\033[0m")
        
        # Detect modules first
        modules = self.detect_modules(user_code)
        if modules['imports'] or modules['from_imports']:
            print("\033[1;97mDetected Modules:\033[0m")
            for imp in modules['imports']:
                print(f"  \033[1;96m• import {imp}\033[0m")
            for from_imp in modules['from_imports']:
                print(f"  \033[1;96m• from {from_imp['module']} import ...\033[0m")
        
        # Initial analysis
        syntax_ok, syntax_msg = self.analyze_syntax(user_code)
        indentation_issues = self.check_indentation(user_code)
        
        print(f"\033[1;97mSyntax Check: {'✓ PASS' if syntax_ok else '✗ FAIL'}\033[0m")
        if not syntax_ok:
            print(f"\033[1;91m{syntax_msg}\033[0m")
            
        if indentation_issues:
            print(f"\033[1;91mIndentation Issues: {len(indentation_issues)} found\033[0m")
            for issue in indentation_issues:
                print(f"  \033[1;91m• {issue}\033[0m")
        else:
            print("\033[1;92mIndentation Check: ✓ PASS\033[0m")
            
        # Apply fixes
        print("\n\033[1;94m" + "═" * 70 + "\033[0m")
        print("\033[1;93mAPPLYING AUTOMATIC FIXES...\033[0m")
        print("\033[1;94m" + "═" * 70 + "\033[0m")
        
        fixed_code, fixes = self.fix_common_errors(user_code)
        
        # Remove modules if requested
        if remove_modules:
            fixed_code = self.remove_modules_and_fix(fixed_code)
            if self.removed_modules:
                fixes.append(f"Removed external modules: {', '.join(self.removed_modules)}")
                print(f"\033[1;92m✓ Removed {len(self.removed_modules)} external modules\033[0m")
        
        fixed_code = self.format_code(fixed_code)
        
        if fixes:
            for fix in fixes:
                print(f"\033[1;92m✓ {fix}\033[0m")
        else:
            print("\033[1;97mNo automatic fixes needed\033[0m")
            
        # Test execution
        print("\n\033[1;94m" + "═" * 70 + "\033[0m")
        print("\033[1;93mTESTING EXECUTION...\033[0m")
        print("\033[1;94m" + "═" * 70 + "\033[0m")
        
        success, output, error = self.capture_output(fixed_code)
        
        if success:
            print("\033[1;92m✓ Code executed successfully!\033[0m")
            if output:
                print(f"\033[1;97mOutput:\n{output}\033[0m")
        else:
            print(f"\033[1;91m✗ Execution failed: {error}\033[0m")
            
        # Suggestions
        suggestions = self.suggest_improvements(fixed_code)
        if suggestions:
            print("\n\033[1;94m" + "═" * 70 + "\033[0m")
            print("\033[1;93mSUGGESTIONS FOR IMPROVEMENT:\033[0m")
            print("\033[1;94m" + "═" * 70 + "\033[0m")
            for suggestion in suggestions:
                print(f"\033[1;96m• {suggestion}\033[0m")
                
        return fixed_code
        
    def interactive_mode(self):
        """Run the tool in interactive mode"""
        self.display_banner()
        self.display_contact_info()
        
        # Show current working directory
        print(f"\033[1;96mCurrent Directory: {os.getcwd()}\033[0m")
        print(f"\033[1;96mOutput Directory: {os.path.abspath(self.output_directory)}\033[0m")
        
        while True:
            print("\n\033[1;95m" + "═" * 70 + "\033[0m")
            print("\033[1;92mCHOOSE AN OPTION:\033[0m")
            print("\033[1;97m1. Enter Python code to fix")
            print("2. Load code from file")
            print("3. View example with modules")
            print("4. Show saved files")
            print("5. Exit")
            print("\033[1;95m" + "═" * 70 + "\033[0m")
            
            choice = input("\033[1;93mEnter your choice (1-5): \033[0m").strip()
            
            if choice == '1':
                print("\n\033[1;96mEnter your Python code (type 'END' on a new line to finish):\033[0m")
                lines = []
                while True:
                    try:
                        line = input()
                        if line.strip() == 'END':
                            break
                        lines.append(line)
                    except EOFError:
                        break
                user_code = '\n'.join(lines)
                
                if user_code.strip():
                    remove_mods = input("\033[1;93mRemove external modules? (y/n): \033[0m").lower() == 'y'
                    custom_name = input("\033[1;93mCustom filename (optional, press Enter for auto): \033[0m").strip()
                    
                    fixed_code = self.process_code(user_code, remove_mods, "manual_input.py")
                    
                    print("\n\033[1;94m" + "═" * 70 + "\033[0m")
                    print("\033[1;93mFIXED CODE:\033[0m")
                    print("\033[1;94m" + "═" * 70 + "\033[0m")
                    print("\033[1;97m" + fixed_code + "\033[0m")
                    
                    # Auto-save with verification
                    print("\n\033[1;94m" + "═" * 70 + "\033[0m")
                    print("\033[1;93mAUTO-SAVING FIXED CODE...\033[0m")
                    print("\033[1;94m" + "═" * 70 + "\033[0m")
                    
                    saved_path = self.save_code_automatically(fixed_code, "manual_input.py", custom_name)
                    
                    if saved_path:
                        print(f"\033[1;92m✓ File successfully created and verified!\033[0m")
                        print(f"\033[1;96m✓ You can run it with: python '{saved_path}'\033[0m")
                        
                        # Ask if user wants to run the saved file
                        run_file = input("\n\033[1;93mRun the saved file now? (y/n): \033[0m").lower()
                        if run_file == 'y':
                            print(f"\033[1;96mExecuting: python '{saved_path}'\033[0m")
                            try:
                                result = subprocess.run([sys.executable, saved_path], capture_output=True, text=True)
                                print(f"\033[1;97mOutput:\n{result.stdout}\033[0m")
                                if result.stderr:
                                    print(f"\033[1;91mErrors:\n{result.stderr}\033[0m")
                            except Exception as e:
                                print(f"\033[1;91mError running file: {e}\033[0m")
                    else:
                        print("\033[1;91m✗ Failed to save file!\033[0m")
                else:
                    print("\033[1;91mNo code entered!\033[0m")
                    
            elif choice == '2':
                filename = input("\n\033[1;93mEnter filename: \033[0m").strip()
                try:
                    with open(filename, 'r', encoding='utf-8') as f:
                        user_code = f.read()
                    
                    remove_mods = input("\033[1;93mRemove external modules? (y/n): \033[0m").lower() == 'y'
                    custom_name = input("\033[1;93mCustom filename (optional, press Enter for auto): \033[0m").strip()
                    
                    fixed_code = self.process_code(user_code, remove_mods, filename)
                    
                    print("\n\033[1;94m" + "═" * 70 + "\033[0m")
                    print("\033[1;93mFIXED CODE:\033[0m")
                    print("\033[1;94m" + "═" * 70 + "\033[0m")
                    print("\033[1;97m" + fixed_code + "\033[0m")
                    
                    # Auto-save with verification
                    print("\n\033[1;94m" + "═" * 70 + "\033[0m")
                    print("\033[1;93mAUTO-SAVING FIXED CODE...\033[0m")
                    print("\033[1;94m" + "═" * 70 + "\033[0m")
                    
                    saved_path = self.save_code_automatically(fixed_code, filename, custom_name)
                    
                    if saved_path:
                        print(f"\033[1;92m✓ File successfully created and verified!\033[0m")
                        print(f"\033[1;96m✓ You can run it with: python '{saved_path}'\033[0m")
                    else:
                        print("\033[1;91m✗ Failed to save file!\033[0m")
                    
                except FileNotFoundError:
                    print(f"\033[1;91mFile not found: {filename}\033[0m")
                except Exception as e:
                    print(f"\033[1;91mError reading file: {e}\033[0m")
                    
            elif choice == '3':
                example_code = '''
import numpy as np
import requests
from bs4 import BeautifulSoup

# Example using external modules
def get_website_data(url):
    response = requests.get(url)
    soup = BeautifulSoup(response.content, 'html.parser')
    titles = soup.find_all('h1')
    
    # Process with numpy
    data = np.array([len(title.text) for title in titles])
    avg_length = np.mean(data)
    
    print(f"Average title length: {avg_length}")
    return data

# Test the function
url = "https://example.com"
results = get_website_data(url)
print(results)
'''
                print("\n\033[1;96mExample Code with External Modules:\033[0m")
                print("\033[1;97m" + example_code + "\033[0m")
                input("\033[1;93mPress Enter to analyze and fix this example...\033[0m")
                
                fixed_code = self.process_code(example_code, remove_modules=True, original_filename="example_with_modules.py")
                
                print("\n\033[1;94m" + "═" * 70 + "\033[0m")
                print("\033[1;93mFIXED CODE (Modules Removed):\033[0m")
                print("\033[1;94m" + "═" * 70 + "\033[0m")
                print("\033[1;97m" + fixed_code + "\033[0m")
                
                # Auto-save with verification
                print("\n\033[1;94m" + "═" * 70 + "\033[0m")
                print("\033[1;93mAUTO-SAVING FIXED CODE...\033[0m")
                print("\033[1;94m" + "═" * 70 + "\033[0m")
                
                saved_path = self.save_code_automatically(fixed_code, "example_with_modules.py")
                
                if saved_path:
                    print(f"\033[1;92m✓ Example successfully saved to: {saved_path}\033[0m")
                else:
                    print("\033[1;91m✗ Failed to save example!\033[0m")
                
            elif choice == '4':
                self.display_saved_files()
                
            elif choice == '5':
                print("\n\033[1;92mThank you for using ChowdhuryVai Code Fixer & Auto-Saver!\033[0m")
                print("\033[1;95mVisit our channels for more tools!\033[0m")
                print(f"\033[1;96mYour fixed codes are saved in: {os.path.abspath(self.output_directory)}\033[0m")
                break
            else:
                print("\033[1;91mInvalid choice! Please try again.\033[0m")

def main():
    """Main function to run the tool"""
    try:
        fixer = ChowdhuryVaiCodeFixer()
        fixer.interactive_mode()
    except KeyboardInterrupt:
        print("\n\n\033[1;91mTool interrupted by user. Goodbye!\033[0m")
    except Exception as e:
        print(f"\n\033[1;91mAn error occurred: {e}\033[0m")
        print(f"\033[1;96mCurrent directory: {os.getcwd()}\033[0m")

if __name__ == "__main__":
    main()
